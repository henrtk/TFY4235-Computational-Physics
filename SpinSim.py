from locale import normalize
import numpy as np
import numba as fast
from numba import float64
import matplotlib.pyplot as plt
import logging as log
from matplotlib import animation
from latticeChange import selectmode
from jitConsts import Consts


log.basicConfig(
        format='%(asctime)s %(levelname)-8s %(message)s',
        level=log.INFO,
        datefmt='%H:%M:%S'
    )


def spinlattice(N, M, random = False,start = np.array([0,0,1])):
    """
    Generate and initialize NxM (Y, X) spinlattice.

    params:
        N      : int        -> N-dimension (plane's Y-axis)
        M      : int        -> M-dimension (plane's X-axis)
        random : Bool       -> decide if inital state is random
        start  : np.ndarray -> inital vector to set all states to if not random
    
    returns:
        spinlattice : np.ndarray(shape = (N, M, 3))
    """
    initial = np.empty(shape = (N,M,3))
    if random:
        randoms = np.random.randn(N*M,3)
        # normalize inital state vector. 
        randoms = randoms/np.linalg.norm(randoms, axis = -1)[...,np.newaxis]
        randoms = np.reshape(randoms,(N,M,3))
        initial = randoms
    else:                  
        initial[:,:] = start
    return initial


#@fast.njit(cache = True)
def HeunsMethodLattice(lattice : np.ndarray, dt : float, steps :int, C : Consts,periodic = False):
    """
    Implements Heun's method to evolve the spin lattice forward in time. 

    params:
        lattice : np.ndarray -> the initial spin lattice state, generated by spinlattice()
        dt      : float      -> time step size
        steps   : int        -> # of steps
        C       : Consts     -> class to carry the system's physical parameters. NumbaJIT-friendly
        periodic: Bool       -> determines the boundary conditions
    
    returns
        lattices: np.ndarray -> The time evolution of the spin lattice calculated by Heun's method.
    """

    log.info(f"Heuns method starting for {steps} steps")
    # Initialize state and data structure
    xMax = len(lattice[0]) 
    yMax = len(lattice[:,0]) 
    lattices = np.empty(shape =(steps+1,yMax,xMax,3), dtype = np.float64)
    lattices[0] = lattice

    # determine evolution function based on dimension and boundary conditions
    f = selectmode(periodic,xMax,yMax)
    
    # initialize RNG parameters for a multivariate normal distribution.
    # generate random thermal force vector outside of Numba for convenience and 
    # parallel threading safely. (Numba does fix this, but only offers a single RNG)
    mean = np.array([0,0,0])
    covs = np.eye(3)
    # evolve lattice iteratively using Heun's method
    for t in range(steps):
        
        randnums = np.random.multivariate_normal(mean,covs,size = (yMax,xMax))
        
        predictor = f(lattices[t],randnums,dt,xMax,yMax,C) 

        yp  = normalize(lattices[t] + dt*predictor)

        corrector = f(yp,randnums,dt,xMax,yMax,C)

        lattices[t+1] = normalize(lattices[t] + dt*(predictor + corrector)/2)

    log.info("Heun's method finished!")
    return lattices



def HeunsMethodForgetful(lattice : np.ndarray, dt : float, steps :int, C : Consts,periodic = False):
    """
    Implements Heun's method to evolve the spin lattice forward in time. 
    Does not save all intermediate states.

    params:
        lattice : np.ndarray -> the initial spin lattice state, generated by spinlattice()
        dt      : float      -> time step size
        steps   : int        -> # of steps
        C       : Consts     -> class to carry the system's physical parameters. NumbaJIT-friendly
        periodic: Bool       -> determines the boundary conditions
    
    returns
        lattices: np.ndarray -> The last calculated state of the spin lattice calculated by Heun's method.
    """

    log.info(f"Heuns method starting for {steps} steps")
    # Initialize state and data structure
    xMax = len(lattice[0]) 
    yMax = len(lattice[:,0]) 

    # determine evolution function based on dimension and boundary conditions
    f = selectmode(periodic,xMax,yMax)
    
    # initialize RNG parameters for a multivariate normal distribution.
    # generate random thermal force vector outside of Numba for convenience and 
    # parallel threading safely. (Numba does fix this, but only offers a single RNG)
    mean = np.array([0,0,0])
    covs = np.eye(3)
    # evolve lattice using Heun's method
    for t in range(steps):
        
        randnums = np.random.multivariate_normal(mean,covs,size = (yMax,xMax))
        
        predictor = f(lattice,randnums,dt,xMax,yMax,C) 

        yp  = normalize(lattice + dt*predictor)

        corrector = f(yp,randnums,dt,xMax,yMax,C)

        lattice = normalize(lattice + dt*(predictor + corrector)/2)

    log.info("Heun's method finished!")
    return lattice


def normalize(vecs):
    """
    Normalizes spin lattice vectors in an easy, simple function simultaneously
    Thank you to Femoen, Viljar for the beautiful, efficient implementation.
    Divides the innermost vectors (A[:,:,..., i]) by their norm to make them unit vectors.

    np.newaxis reintroduces the lost axis after the innermost vector dimension is normed (axis = -1)
    """
    return vecs/np.linalg.norm(vecs,axis=-1)[...,np.newaxis]
    

def magnetizationTimeavg(lattices,separation = 10):
    """
    Calculate the magnetization ensemble (/time) average of a a steady state. 
    If lattices is a time single slice, return only its average.
    If lattices has more time slices, calculate mean for the slices and then get mean of the means.
    Empirical standard deviation of the means 

    
    """
    
    
    if len(lattices[:,:,2].shape) == 2:
        return np.mean(lattices[:,:,2]), np.std(lattices[:,:,2],ddof=1)

    mag = np.zeros(len(lattices))
    for i in range(0,lattices.shape[0],separation):
        # separation decides sampling frequency. 
        # Large separation eliminates the time correlation of magnetization for 
        # between temporally close states. 
        mag[i] = np.mean(lattices[i,:,:,2])
    
    # make up for the fact that mag hasnt been fully filled if separation is not unity.
    mag = mag[mag.nonzero()]

    
    return np.mean(mag), np.std(mag,ddof=1)


if __name__ == "__main__":
    pass

    



