from locale import normalize
import numpy as np
import numba as fast
from numba import float64
import matplotlib.pyplot as plt
import logging as log
from matplotlib import animation
from latticeChange import selectmode
from jitConsts import Consts


log.basicConfig(
        format='%(asctime)s %(levelname)-8s %(message)s',
        level=log.INFO,
        datefmt='%H:%M:%S'
    )


def spinlattice(N, M, random = False,start = np.array([0,0,1])):
    """
    Generate and initialize NxM spinlattice 

    returns:
        spinlattice : np.ndarray(shape = (N, N, 3))
    """
    initial = np.empty(shape = (N,M,3))
    if random:
        randoms = np.random.randn(N*M,3)
        # normalize inital state vector. 
        randoms = randoms/np.linalg.norm(randoms, axis = -1)[...,np.newaxis]
        randoms = np.reshape(randoms,(N,M,3))
        initial = randoms
        print(initial.shape)
    else:                  
        initial[:,:] = start
    return initial


#@fast.njit(cache = True)
def HeunsMethod3dLattice(lattice : np.ndarray, dt : float, steps :int, C : Consts,periodic = False):
    """
    Implements Heun's method to evolve the spin lattice forward in time 

    params:
        lattice : np.ndarray -> the initial spin lattice state, generated by spinlattice()
        dt      : float      -> time step size
        steps   : int        -> # of steps
        C       : Consts     -> class to carry the system's physical parameters. NumbaJIT-friendly
        periodic: Bool       -> determines the boundary conditions
    
    returns
        lattices: np.ndarray -> The time evolution of the spin lattice calculated by Heun's method.
    """

    log.info(f"Heuns method starting for {steps} steps")
    # Initialize state and data structure
    xMax = len(lattice[0]) 
    yMax = len(lattice[:,0]) 
    lattices = np.empty(shape =(steps+1,yMax,xMax,3), dtype = np.float64)
    lattices[0] = lattice

    # determine evolution function based on dimension and boundary conditions
    f = selectmode(periodic,xMax,yMax)
    # initialize RNG parameters
    mean = np.array([0,0,0])
    covs = np.eye(3)

    # evolve lattice using Heun's method
    for t in range(steps):
        # generate random thermal force vector outside of Numba for convenience and 
        # parallel threading safely. (Numba does fix this also, but only offers a single RNG)
        randnums = np.random.multivariate_normal(mean,covs,size = (yMax,xMax))
        
        # generate predictor
        predictor = f(lattices[t],randnums,dt,xMax,yMax,C) 

        yp  = normalize(lattices[t] + dt*predictor)

        corrector = f(yp,randnums,dt,xMax,yMax,C)

        # get next state
        lattices[t+1] = normalize(lattices[t] + dt*(predictor + corrector)/2)

    log.info("Heun's method finished!")
    return lattices


def normalize(vecs):
    """
    Normalizes spin lattice vectors in an easy, simple function simultaneously
    Thank you to Femoen, Viljar for the beautiful, efficient implementation.
    Divides the innermost vectors (A[:,:,..., i]) by their norm to make them unit vectors.

    np.newaxis reintroduces the lost axis after the innermost vector dimension is normed (axis = -1)
    """
    return vecs/np.linalg.norm(vecs,axis=-1)[...,np.newaxis]
    
@fast.njit()
def magnetizationTimeavg(lattices,xmax,ymax):
    N = xmax*ymax*len(lattices)
    mag = 0
    ez = np.array([0,0,1])
    for lattice in lattices:

        for y in range(xmax):

            for x in range(ymax):

                mag += np.dot(lattice[y,x],ez)
    
    return mag/N


if __name__ == "__main__":
    consts = Consts(ALPHA=0.1,GAMMA=0.176,J = 1,KBT=0.1*0,B = np.array([0,0,1],dtype=np.float64),d_z = 0,magMom = 5.788*10**-2)

    consts.ALPHA = 0.01

    



